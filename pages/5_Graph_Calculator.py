import streamlit as st
import networkx as nx
import os
from fractions import Fraction
from pyvis.network import Network
import streamlit.components.v1 as components
from functions import (
    make_graph_dataframe,
    invariants,
    booleans,
)

from functions.invariant_functions import compute

# Utility functions
def create_empty_graph(n):
    G = nx.Graph()
    G.add_nodes_from(range(1, n + 1))
    return G

def add_edges_from_list(graph, edge_list):
    for edge in edge_list:
        node1, node2 = edge.split('-')
        graph.add_edge(int(node1), int(node2))
    return graph

def draw_graph(graph):
    net = Network(height='500px', width='100%', notebook=True)
    for node in graph.nodes:
        net.add_node(node, label=str(node))
    for edge in graph.edges:
        net.add_edge(edge[0], edge[1])
    return net.generate_html()

def get_potential_neighbors(graph, node, num_vertices):
    # Return a list of nodes that are not yet neighbors of the given node
    neighbors = set(graph.neighbors(node))
    all_nodes = set(range(1, num_vertices + 1))
    return list(all_nodes - neighbors - {node})  # Remove current neighbors and itself

def enter_counterexample():
    st.set_page_config(page_title="Counter-Examples")
    st.markdown("""
        # Compute Graph Properties

        This page allows you to compute properties of a graph and add edges to the graph.
        You can also add edges to the graph and compute properties of the graph.
        This page is useful for testing the conjectures generated by TxGraffiti.
    """)

    # Step 1: Input number of vertices
    num_vertices = st.number_input("Number of vertices", min_value=1, max_value=20, value=5, key="num_vertices_counter")

    # Step 2: Checkbox to ask if user wants to provide edges
    provide_edges = st.checkbox("Provide initial list of edges?", key="provide_edges_counter")

    # Step 3: If user provides edges, input box for edges
    edge_list = []
    if provide_edges:
        edges = st.text_input("Enter edges as '1-2, 2-3, 3-4'", key="edge_input_counter")
        if edges:
            edge_list = [e.strip() for e in edges.split(',')]

    # Step 4: Create graph
    create_graph = st.button("Create Graph", key="create_graph_counter")

    if create_graph:
        graph = create_empty_graph(num_vertices)
        if edge_list:
            graph = add_edges_from_list(graph, edge_list)
        st.session_state.graph_counter = graph

    # Step 5: Graph manipulation and property computation
    if 'graph_counter' in st.session_state:
        graph = st.session_state.graph_counter

        st.subheader("Graph Editor")
        graph_html = draw_graph(graph)
        components.html(graph_html, height=600)

        st.subheader("Add Edges")
        for node in range(1, num_vertices + 1):
            st.write(f"Vertex {node}:")
            potential_neighbors = get_potential_neighbors(graph, node, num_vertices)
            if potential_neighbors:
                for neighbor in potential_neighbors:
                    if st.button(f"Add edge {node}-{neighbor}"):
                        graph.add_edge(node, neighbor)
                        st.session_state.graph_counter = graph
                        st.rerun()

        st.subheader("Compute Graph Properties")
        properties = booleans + invariants

        property1 = st.selectbox("Property 1", properties, key="property1")
        value1 = compute(graph, property1)
        st.write(f"{property1}: {value1}")

        property2 = st.selectbox("Property 2", properties, key="property2")
        value2 = compute(graph, property2)
        st.write(f"{property2}: {value2}")

        property3 = st.selectbox("Property 3", properties, key="property3")
        value3 = compute(graph, property3)
        st.write(f"{property3}: {value3}")

        property4 = st.selectbox("Property 4", properties, key="property4")
        value4 = compute(graph, property4)
        st.write(f"{property4}: {value4}")

enter_counterexample()
